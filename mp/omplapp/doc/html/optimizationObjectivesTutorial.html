<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Optimization Objectives Tutorial</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Ioan A. È˜ucan, Mark Moll, Lydia E. Kavraki">
  <link href="../css/tabs.css" rel="stylesheet">
  <link href="../css/doxygen.css" rel="stylesheet">
  <link href="../css/search.css" rel="stylesheet">
  <link href="../css/bootstrap.min.css" rel="stylesheet">
  <link href="../css/bootstrap-theme.min.css" rel="stylesheet">
  <link href="../css/ompl.css" rel="stylesheet">
  <!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
  <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->
  <script src="search/search.js"></script>
</head>
<body>
  <nav class="navbar navbar-inverse navbar-fixed-top" id="top" role="navigation">
    <div class="container">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="./index.html">OMPL</a>
      </div>
      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse navbar-collapse" id="navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="download.html">Download</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="http://ompl.kavrakilab.org/OMPL_Primer.pdf">Primer</a></li>
              <li><a href="installation.html">Installation</a></li>
              <li><a href="tutorials.html">Tutorials</a></li>
              <li><a href="group__demos.html">Demos</a></li>
              <li><a href="gui.html">OMPL.app GUI</a></li>
              <li><a href="python.html">Python Bindings</a></li>
              <li><a href="planners.html">Available Planners</a></li>
              <li><a href="spaces.html">Available State Spaces</a></li>
              <li><a href="optimalPlanning.html">Optimal Planning</a></li>
              <li><a href="FAQ.html">FAQ</a></li>
              <li class="divider"></li>
              <li>&nbsp;<em>External links:</em></li>
              <li><a href="http://moveit.ros.org">MoveIt!</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FOMPL">Japanese Introduction to OMPL</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FExercise%2FOMPLProgramming">Japanese OMPL Tutorial</a></li>
              <li><a href="http://moveit.ros.org/wiki/Tutorials/ICRA2013">ICRA 2013 Tutorial</a></li>
              <li><a href="http://kavrakilab.org/OMPLtutorial">IROS 2011 Tutorial</a></li>
            </ul>
          </li>
          <li><a href="gallery.html">Gallery</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Code <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="api_overview.html">API Overview</a></li>
              <li><a href="annotated.html">Classes</a></li>
              <li><a href="files.html">Files</a></li>
              <li><a href="styleGuide.html">Style Guide</a></li>
              <li><a href="https://bitbucket.org/ompl/ompl/src">Browse Repository</a></li>
              <li><a href="teamcity.html">TeamCity Build Server</a></li>
            </ul>
          </li>
          <li><a href="https://bitbucket.org/ompl/ompl/issues?status=new&status=open">Issues</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="mailingLists.html">Mailing Lists</a></li>
              <li><a href="developers.html">Developers</a></li>
              <li><a href="thirdparty.html">Contributions</a></li>
              <li><a href="contrib.html">Submit Contribution</a></li>
              <li><a href="education.html">Education</a></li>
            </ul>
          </li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="license.html">License</a></li>
              <li><a href="citations.html">Citations</a></li>
              <li><a href="acknowledgements.html">Acknowledgments</a></li>
              <li><a href="contact.html">Contact Us</a></li>
            </ul>
          </li>
          <li><a href="http://ompl.kavrakilab.org/blog/">Blog</a></li>
          <!-- Doxygen API search box -->
          <div id="searchli">
            <div id="MSearchBox" class="MSearchBoxInactive">
              <span class="left">
                <img id="MSearchSelect" src="search/mag_sel.png"
                onmouseover="return searchBox.OnSearchSelectShow()"
                onmouseout="return searchBox.OnSearchSelectHide()"
                alt=""/>
                <input type="text" id="MSearchField" value="Search API" accesskey="S"
                onfocus="searchBox.OnSearchFieldFocus(true)"
                onblur="searchBox.OnSearchFieldFocus(false)"
                onkeyup="searchBox.OnSearchFieldChange(event)"/>
              </span><span class="right">
                <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
              </span>
            </div>
          </div>
        </ul>
      </div>
    </div>
  </nav>
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"
  onmouseover="return searchBox.OnSearchSelectShow()"
  onmouseout="return searchBox.OnSearchSelectHide()"
  onkeydown="return searchBox.OnSearchSelectKey(event)">
  <a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow">
    <iframe src="" frameborder="0"name="MSearchResults" id="MSearchResults"></iframe>
  </div>
  <div class="container" role="main">
    <div>
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Optimization Objectives Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this tutorial, we'll discuss how to implement your own customized optimization objectives for optimizing planners. We'll continue using the <a href="optimalPlanningTutorial.html">previous tutorial</a>'s example planning problem with the 2D robot and circular obstacle.</p>
<h2>Specifying a new objective (part 1): path clearance</h2>
<p>Previously, we considered optimal planning in terms of minimizing the length of the path found. However, this path tends to steer very close to obstacles, which can sometimes be unsafe. For safety reasons, let's define an objective which attempts to steer the robot away from obstacles. For this example, we chose to represent our metric of a path's clearance from obstacles as a summation of state costs along the path, where each state cost is a function of the state's clearance from obstacles.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ClearanceObjective : <span class="keyword">public</span> <a class="code" href="classompl_1_1base_1_1StateCostIntegralObjective.html">ob::StateCostIntegralObjective</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ClearanceObjective(<span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1SpaceInformationPtr.html">ob::SpaceInformationPtr</a>&amp; si) :</div>
<div class="line">        ob::StateCostIntegralObjective(si, true)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> <a class="code" href="classompl_1_1base_1_1OptimizationObjective.html#af589c396f89c8d54b4e36e87b6227220">stateCost</a>(<span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1State.html">ob::State</a>* s)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a>(1 / si_-&gt;getStateValidityChecker()-&gt;clearance(s));</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above code fragment, you'll see that we've defined our path clearance objective as a subclass of <code><a class="el" href="classompl_1_1base_1_1StateCostIntegralObjective.html" title="Defines optimization objectives where path cost can be represented as a path integral over a cost fun...">ompl::base::StateCostIntegralObjective</a></code>. This is because <code><a class="el" href="classompl_1_1base_1_1StateCostIntegralObjective.html" title="Defines optimization objectives where path cost can be represented as a path integral over a cost fun...">ompl::base::StateCostIntegralObjective</a></code> represents objectives as summations of state costs, which is exactly what we require. Therefore, all we need to do to completely specify our path clearance objective is to inherit from <code><a class="el" href="classompl_1_1base_1_1StateCostIntegralObjective.html" title="Defines optimization objectives where path cost can be represented as a path integral over a cost fun...">ompl::base::StateCostIntegralObjective</a></code> and specify our state cost function by overriding the <code><a class="el" href="classompl_1_1base_1_1OptimizationObjective.html#af589c396f89c8d54b4e36e87b6227220" title="Evaluate a cost map defined on the state space at a state s. Default implementation maps all states t...">ompl::base::OptimizationObjective::stateCost()</a></code> method.</p>
<p>Now, let's talk about the counterintuitive implementation of <code><a class="el" href="classompl_1_1base_1_1OptimizationObjective.html#af589c396f89c8d54b4e36e87b6227220" title="Evaluate a cost map defined on the state space at a state s. Default implementation maps all states t...">ompl::base::OptimizationObjective::stateCost()</a></code>. By default, optimization objectives seek to <em>minimize</em> path cost. For our path clearance objective, we want paths to <em>maximize</em> path clearance. Therefore, we want our state cost function to return <em>smaller</em> costs when states have <em>greater</em> clearance from obstacles. An easy way to do this is to simply define the state cost as the reciprocal of that state's clearance.</p>
<p>Lastly, notice that in <code>ClearanceObjective</code>'s constructor we initialized the <code><a class="el" href="classompl_1_1base_1_1StateCostIntegralObjective.html" title="Defines optimization objectives where path cost can be represented as a path integral over a cost fun...">ompl::base::StateCostIntegralObjective</a></code> with the additional argument <code>true</code>. This changes the behaviour of the objective to use motion cost interpolation when summing up state costs along the path. By default, <code><a class="el" href="classompl_1_1base_1_1StateCostIntegralObjective.html" title="Defines optimization objectives where path cost can be represented as a path integral over a cost fun...">ompl::base::StateCostIntegralObjective</a></code> simply takes the individual states that make up a given path, and sums up those costs. However, this approach can result in an inaccurate estimation of the path cost if successive states on the path are far apart. If we enable motion cost interpolation the path cost computation will interpolate between distant states in order to get a more accurate approximation of the true path cost. This interpolation of states along a path is the same as the one used in <code><a class="el" href="classompl_1_1base_1_1DiscreteMotionValidator.html" title="A motion validator that only uses the state validity checker. Motions are checked for validity at a s...">ompl::base::DiscreteMotionValidator</a></code>. Note that the increase in accuracy by using motion cost interpolation comes with a decrease in computational effiency due to more calls to <code><a class="el" href="classompl_1_1base_1_1OptimizationObjective.html#af589c396f89c8d54b4e36e87b6227220" title="Evaluate a cost map defined on the state space at a state s. Default implementation maps all states t...">ompl::base::OptimizationObjective::stateCost</a></code>.</p>
<p>Here's an animation demonstrating the RRTstar algorithm's progress in planning under the above objective:</p>
<div class="row"><div class="image">
<img src="../images/clearance.gif"  class="col-md-8 col-sm-8 col-md-push-1 col-sm-push-1"/>
</div>
</div><h2>Multiobjective optimal planning</h2>
<p>In some cases you might be interested in optimal planning under more than one objective. For instance, we might want to specify some balance between path clearance and path length. We can do this using the <code><a class="el" href="classompl_1_1base_1_1MultiOptimizationObjective.html" title="This class allows for the definition of multiobjective optimal planning problems. Objectives are adde...">ompl::base::MultiOptimizationObjective</a></code> class.</p>
<div class="fragment"><div class="line"><a class="code" href="classompl_1_1base_1_1OptimizationObjectivePtr.html">ob::OptimizationObjectivePtr</a> getBalancedObjective(<span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1SpaceInformationPtr.html">ob::SpaceInformationPtr</a>&amp; si)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classompl_1_1base_1_1OptimizationObjectivePtr.html">ob::OptimizationObjectivePtr</a> lengthObj(<span class="keyword">new</span> <a class="code" href="classompl_1_1base_1_1PathLengthOptimizationObjective.html">ob::PathLengthOptimizationObjective</a>(si));</div>
<div class="line">    <a class="code" href="classompl_1_1base_1_1OptimizationObjectivePtr.html">ob::OptimizationObjectivePtr</a> clearObj(<span class="keyword">new</span> ClearanceObjective(si));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classompl_1_1base_1_1MultiOptimizationObjective.html">ob::MultiOptimizationObjective</a>* opt = <span class="keyword">new</span> <a class="code" href="classompl_1_1base_1_1MultiOptimizationObjective.html">ob::MultiOptimizationObjective</a>(si);</div>
<div class="line">    opt-&gt;<a class="code" href="classompl_1_1base_1_1MultiOptimizationObjective.html#adc1f3daeac02055c1f43066496a9851c">addObjective</a>(lengthObj, 10.0);</div>
<div class="line">    opt-&gt;<a class="code" href="classompl_1_1base_1_1MultiOptimizationObjective.html#adc1f3daeac02055c1f43066496a9851c">addObjective</a>(clearObj, 1.0);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="classompl_1_1base_1_1OptimizationObjectivePtr.html">ob::OptimizationObjectivePtr</a>(opt);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The above code fragment creates and optimization objective which attempts to optimize both path length and clearance. We begin by defining each of the individual objectives, and then we add them to a <code><a class="el" href="classompl_1_1base_1_1MultiOptimizationObjective.html" title="This class allows for the definition of multiobjective optimal planning problems. Objectives are adde...">ompl::base::MultiOptimizationObjective</a></code> object. This results in an optimization objective where path cost is equivalent to summing up each of the individual objectives' path costs. When we add objectives to <code><a class="el" href="classompl_1_1base_1_1MultiOptimizationObjective.html" title="This class allows for the definition of multiobjective optimal planning problems. Objectives are adde...">ompl::base::MultiOptimizationObjective</a></code>, we must also optionally specify each objective's weighting factor to signify how important it is in optimal planning. In the above example, we weigh the length with a factor of 10.0 and the clearance with a factor of 1.0 to try to balance more in favor of minimizing path length in planning. This objective results in a path which still maintains clearance from the circle, but not as much as before.</p>
<p>We also provide a more concise way to define multiple optimization objectives using operator overloading:</p>
<div class="fragment"><div class="line"><a class="code" href="classompl_1_1base_1_1OptimizationObjectivePtr.html">ob::OptimizationObjectivePtr</a> getBalancedObjective(<span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1SpaceInformationPtr.html">ob::SpaceInformationPtr</a>&amp; si)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classompl_1_1base_1_1OptimizationObjectivePtr.html">ob::OptimizationObjectivePtr</a> lengthObj(<span class="keyword">new</span> <a class="code" href="classompl_1_1base_1_1PathLengthOptimizationObjective.html">ob::PathLengthOptimizationObjective</a>(si));</div>
<div class="line">    <a class="code" href="classompl_1_1base_1_1OptimizationObjectivePtr.html">ob::OptimizationObjectivePtr</a> clearObj(<span class="keyword">new</span> ClearanceObjective(si));</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 10.0*lengthObj + clearObj;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function defines exactly the same optimization objective as the previous one, but uses fewer lines of code and represents the objective in a semantically rich form.</p>
<p>Here's an animation of the RRTstar algorithm's progress on this multiobjective problem:</p>
<div class="row"><div class="image">
<img src="../images/balanced.gif"  class="col-md-8 col-sm-8 col-md-push-1 col-sm-push-1"/>
</div>
</div><h2>Specifying a new objective (part 2): maximize minimum clearance</h2>
<p>Now we'll implement an objective which will require a lot more tinkering with the rest of the methods in <code><a class="el" href="classompl_1_1base_1_1OptimizationObjective.html" title="Abstract definition of optimization objectives. ">ompl::base::OptimizationObjective</a></code>. This objective attemps to <em>maximize the minimum path clearance</em>; that is, the cost of a given path is only a function of the closest distance between the path and an obstacle. This objective has already been implemented for you as <code><a class="el" href="classompl_1_1base_1_1MaximizeMinClearanceObjective.html" title="Objective for attempting to maximize the minimum clearance along a path. ">ompl::base::MaximizeMinClearanceObjective</a></code>, but we'll walk you through your own implementation of it.</p>
<p>Here's the interface of our new objective, <code>MaximizeMinClearance</code>: </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MaximizeMinClearance : <span class="keyword">public</span> <a class="code" href="classompl_1_1base_1_1OptimizationObjective.html">ob::OptimizationObjective</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MaximizeMinClearance(<span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1SpaceInformationPtr.html">ob::SpaceInformationPtr</a> &amp;si) :</div>
<div class="line">        ob::OptimizationObjective(si) {}</div>
<div class="line"></div>
<div class="line">    <span class="keyword">virtual</span> <a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> <a class="code" href="classompl_1_1base_1_1OptimizationObjective.html#af589c396f89c8d54b4e36e87b6227220">stateCost</a>(<span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1State.html">ob::State</a>* s) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classompl_1_1base_1_1OptimizationObjective.html#ad6ba0ff250adc0cb8cb0863d0f4d23b5">isCostBetterThan</a>(<a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> c1, <a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> c2) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> <a class="code" href="classompl_1_1base_1_1OptimizationObjective.html#aa8dc9a1b7952491f6938ee8279d3a179">motionCost</a>(<span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1State.html">ob::State</a> *s1, <span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1State.html">ob::State</a> *s2) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> <a class="code" href="classompl_1_1base_1_1OptimizationObjective.html#abef844b078ccaf3f30edd7d005ff24df">combineCosts</a>(<a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> c1, <a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> c2) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> <a class="code" href="classompl_1_1base_1_1OptimizationObjective.html#af2eb3b8f8e56732005273ce8e15b2986">identityCost</a>() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> <a class="code" href="classompl_1_1base_1_1OptimizationObjective.html#a14f3566ca58d1c72bbf8e2318001002f">infiniteCost</a>() <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>There're lots of methods here, but we're have some really cool functionality once we've finished! We'll go through the methods one by one.</p>
<p>Like in the previous objectives, we can reason about the cost of a path by reasoning about the costs of individual states. Let's define our state cost:</p>
<div class="fragment"><div class="line"><a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> MaximizeMinClearance::stateCost(<span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1State.html">ob::State</a>* s)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a>(this-&gt;si_-&gt;getStateValidityChecker()-&gt;clearance(s));</div>
<div class="line">}</div>
</div><!-- fragment --><p>You'll notice that we didn't use the reciprocal of the clearance as before. This is because, in the previous case, we were constraining ourselves to considering optimal planning as a <em>minimization</em> of path cost (this was so that we could make use of the already-implemented functionality in <code><a class="el" href="classompl_1_1base_1_1StateCostIntegralObjective.html" title="Defines optimization objectives where path cost can be represented as a path integral over a cost fun...">ompl::base::StateCostIntegralObjective</a></code>). However, we can turn the objective into a <em>maximization</em> of cost (and therefore a maximization of clearance) by overriding the <code><a class="el" href="classompl_1_1base_1_1OptimizationObjective.html#ad6ba0ff250adc0cb8cb0863d0f4d23b5" title="Check whether the the cost c1 is considered better than the cost c2. By default, this returns true on...">ompl::base::OptimizationObjective::isCostBetterThan</a></code> method:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> MaximizeMinClearance::isCostBetterThan(<a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> c1, <a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> c2)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> c1.<a class="code" href="structompl_1_1base_1_1Cost.html#a2f0ece6f8517fe9a49d27b5855426ee6">v</a> &gt; c2.<a class="code" href="structompl_1_1base_1_1Cost.html#a2f0ece6f8517fe9a49d27b5855426ee6">v</a> + <a class="code" href="namespaceompl_1_1magic.html#a4e8b9c1383bfdea5de681fc55c2119bf">ompl::magic::BETTER_PATH_COST_MARGIN</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Optimizing planners use this method to decide whether one path is better than another. It takes two cost values, <code>c1</code> and <code>c2</code>, and returns <code>true</code> if <code>c1</code> is considered a better cost than <code>c2</code> by some threshold. The objects of type <code><a class="el" href="structompl_1_1base_1_1Cost.html" title="Definition of a cost value. Can represent the cost of a motion or the cost of a state. ">ompl::base::Cost</a></code> are simply wrappers for <code>double</code> values which can be accessed with <code><a class="el" href="structompl_1_1base_1_1Cost.html#a2f0ece6f8517fe9a49d27b5855426ee6" title="The value of the cost. ">ompl::base::Cost::v</a></code>; so, cost <code>c1</code> is considered better than cost <code>c2</code> if <code>c1</code>'s value (path clearance) is greater than that of <code>c2</code>. We add the threshold <code><a class="el" href="namespaceompl_1_1magic.html#a4e8b9c1383bfdea5de681fc55c2119bf" title="When running algorithms such as RRT*, rewire updates are made when the cost of a path appears better ...">ompl::magic::BETTER_PATH_COST_MARGIN</a></code> to ensure numerical robustness in the optimizing planners. We recommend you use this threshold too if you override <code><a class="el" href="classompl_1_1base_1_1OptimizationObjective.html#ad6ba0ff250adc0cb8cb0863d0f4d23b5" title="Check whether the the cost c1 is considered better than the cost c2. By default, this returns true on...">ompl::base::OptimizationObjective::isCostBetterThan</a></code>.</p>
<blockquote class="doxtable">
<p>Note: You might be wondering why we took the trouble of wrapping <code>double</code> values in a class to represent costs (instead of using a <code>typedef</code> for instance). The reason why is <em>type safety</em>. If <code><a class="el" href="structompl_1_1base_1_1Cost.html" title="Definition of a cost value. Can represent the cost of a motion or the cost of a state. ">ompl::base::Cost</a></code> were simply a <code>typedef</code> of <code>double</code>, a user might accidentally use the <code>&lt;</code> operator instead of <code><a class="el" href="classompl_1_1base_1_1OptimizationObjective.html#ad6ba0ff250adc0cb8cb0863d0f4d23b5" title="Check whether the the cost c1 is considered better than the cost c2. By default, this returns true on...">ompl::base::OptimizationObjective::isCostBetterThan</a></code>, which could cause some hard-to-find errors (this author knows from experience!). By using an object to represent costs, this mistake will be caught by the compiler.</p>
<p></p>
</blockquote>
<p>In a way, maximizing minimum clearance can be formulated similarly to the previous objectives. Your path is a sequence of states, and the path cost can still be represented as a special combination of the state costs along the path; while in the previous cases, this combination was addition, in the case of minimum clearance, the combination is the <em>min</em> function. We can therefore specify this functionality for our objective by overriding the <code><a class="el" href="classompl_1_1base_1_1OptimizationObjective.html#abef844b078ccaf3f30edd7d005ff24df" title="Get the cost that corresponds to combining the costs c1 and c2. Default implementation defines this c...">ompl::base::OptimizationObjective::combineCosts</a></code> method:</p>
<div class="fragment"><div class="line"><a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> MaximizeMinClearance::combineCosts(<a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> c1, <a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> c2)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">if</span> (c1.<a class="code" href="structompl_1_1base_1_1Cost.html#a2f0ece6f8517fe9a49d27b5855426ee6">v</a> &lt; c2.<a class="code" href="structompl_1_1base_1_1Cost.html#a2f0ece6f8517fe9a49d27b5855426ee6">v</a>)</div>
<div class="line">        <span class="keywordflow">return</span> c1;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        <span class="keywordflow">return</span> c2;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The implementation of this method in the base class <code><a class="el" href="classompl_1_1base_1_1OptimizationObjective.html" title="Abstract definition of optimization objectives. ">ompl::base::OptimizationObjective</a></code> simply sums the two costs given as arguments. In our case, we return the minimum of the two costs, which is equivalent to returning the minimum clearance of the two. If we accumulate the cost of a path using this operation instead of addition, we'll get the minimum clearance of the entire path as desired.</p>
<p>Next, we need to specify how to compute the cost of a <em>motion</em> defined by the two endpoints of the motion. Technically, the cost of the motion comes from the minimum clearance over the entire continuum of states along that motion. In most real-world motion planning problems this is very difficult to compute, so we have to settle for an approximation. One approximation is to simply take the the minimum of the clearances of the two endpoints; we'll implement this approximation as an example for simplicity, but it's a much better idea to sample some interpolating states along the motion for more accuracy, as is done in <code><a class="el" href="classompl_1_1base_1_1MinimaxObjective.html#a2918c3aad30a1b88da44b0a57d4080bc" title="Interpolates between s1 and s2 to check for state costs along the motion between the two states...">ompl::base::MinimaxObjective::motionCost</a></code>. Here's how we implement the two-endpoint approximation of motion cost:</p>
<div class="fragment"><div class="line"><a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> MaximizeMinClearance::motionCost(<a class="code" href="classompl_1_1base_1_1State.html">ob::State</a> *s1, <a class="code" href="classompl_1_1base_1_1State.html">ob::State</a> *s2)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;combineCosts(this-&gt;stateCost(s1), this-&gt;stateCost(s2));</div>
<div class="line">}</div>
</div><!-- fragment --><p>You'll notice that this simple approximation of motion cost can be implemented using our already-defined <code>combineCost</code> and <code>stateCost</code> methods.</p>
<p>Many optimizing planners count on their objectives having certain cost values which have special properties. One common cost value is the <em>identity cost</em>. This is a cost value <code>c0</code> which, when combined with any other cost value <code>c1</code> using <code>combineCost</code>, always returns the value <code>c1</code>. For example, when <code>combineCost</code> is simple addition, the identity cost is 0. We can specify an objective's identity cost by overriding the <code><a class="el" href="classompl_1_1base_1_1OptimizationObjective.html#af2eb3b8f8e56732005273ce8e15b2986" title="Get the identity cost value. The identity cost value is the cost c_i such that, for all costs c...">ompl::base::OptimizationObjective::identityCost</a></code> method; but what is the identity cost of our minimum cost objective? It's a cost that, when combined with another cost with the <em>min</em> function, always returns the other cost. This means that the identity cost must be <em>greater</em> than every other cost - in other words, infinity!</p>
<div class="fragment"><div class="line"><a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> MaximizeMinClearance::identityCost()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a>(std::numeric_limits&lt;double&gt;::infinity());</div>
<div class="line">}</div>
</div><!-- fragment --><p>We define the identity cost of our minimum path clearance objective to be infinity. Because we're working with costs, we wrap the <code>double</code> value of infinity in a <code>Cost</code> object.</p>
<p>Another cost value commonly used in optimizing planners is the <em>infinite cost</em>. This is a cost which is <em>worse than all other cost values</em>; in other words, it's a value <code>c_i</code> for which <code>isCostBetterThan(c_i, c)</code> is false for all values of <code>c</code>. In the case of our minimum clearance objective, we can use the value of negative infinity to fulfill this role. We specify this by overriding the <code><a class="el" href="classompl_1_1base_1_1OptimizationObjective.html#a14f3566ca58d1c72bbf8e2318001002f" title="Get a cost which is greater than all other costs in this OptimizationObjective; required for use in D...">ompl::base::OptimizationObjective::infiniteCost</a></code> method:</p>
<div class="fragment"><div class="line"><a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a> MaximizeMinClearance::infiniteCost()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structompl_1_1base_1_1Cost.html">ob::Cost</a>(-std::numeric_limits&lt;double&gt;::infinity());</div>
<div class="line">}</div>
</div><!-- fragment --><p>Our objective is now ready to be used for planning! In the previous tutorial, we used the <code><a class="el" href="classompl_1_1geometric_1_1RRTstar.html" title="Optimal Rapidly-exploring Random Trees. ">ompl::geometric::RRTstar</a></code> planner for optimal planning; you may find you get nicer results if you use the <code><a class="el" href="classompl_1_1geometric_1_1PRMstar.html" title="PRM* planner. ">ompl::geometric::PRMstar</a></code> planner for this problem. You can use it with the following code (after defining your planning problem and optimization objective):</p>
<div class="fragment"><div class="line"><a class="code" href="classompl_1_1base_1_1PlannerPtr.html">ob::PlannerPtr</a> planner(<span class="keyword">new</span> <a class="code" href="classompl_1_1geometric_1_1PRMstar.html">og::PRMstar</a>(si));</div>
<div class="line">planner-&gt;setProblemDefinition(pdef);</div>
<div class="line">planner-&gt;setup();</div>
<div class="line"><a class="code" href="structompl_1_1base_1_1PlannerStatus.html">ob::PlannerStatus</a> solved = planner-&gt;solve(timeLimit);</div>
</div><!-- fragment --><h2>Cost Heuristics</h2>
<p>Some optimizing motion planners such as <code><a class="el" href="classompl_1_1geometric_1_1PRMstar.html" title="PRM* planner. ">ompl::geometric::PRMstar</a></code> can plan more efficiently if you provide them with <em>cost heuristics</em>. A heuristic is a function which quickly computes an approximation of some value. There are two kinds of cost heuristics defined in OMPL:</p>
<ul>
<li><em>Motion cost heuristics</em> approximate the cost of the optimal path between two given states</li>
<li><em>Cost-to-go heuristics</em> approximate the cost of the optimal path between a given state and the goal</li>
</ul>
<p>Specifying cost heuristics for an optimization objective can speed up the planning process by providing optimizing planners a fast way to get more information about a planning problem.</p>
<h3>Admissible heuristics</h3>
<p>In order for optimizing planners to most effectively use a cost heuristic, the cost heuristic must have an important property called <em>admissibility</em>. An admissible cost heuristic always <em>underestimates</em> the cost of a path. That is, if the true optimal cost of a path is <code>c_o</code>, an admissible heuristic <em>never</em> returns a cost <code>c_h</code> such that <code>isCostBetterThan(c_o, c_h)</code> is true.</p>
<h3>Motion cost heuristics</h3>
<p>Let's consider what an admissible motion cost heuristic would look like when planning to minimize path length for a 2D point robot. The shortest possible path between two points is a straight line. We can quickly compute the length of this path with <code><a class="el" href="classompl_1_1base_1_1SpaceInformation.html#ac8cadda9547f74d4193c3168a3b2d34f" title="Compute the distance between two states. ">ompl::base::SpaceInformation::distance</a></code>. Note that the true optimal path between the two points might be longer because of obstacles in the environment; however, we can at least guarantee that the value returned by <code><a class="el" href="classompl_1_1base_1_1SpaceInformation.html#ac8cadda9547f74d4193c3168a3b2d34f" title="Compute the distance between two states. ">ompl::base::SpaceInformation::distance</a></code> is never longer than length of the truly optimal path. Therefore, <code><a class="el" href="classompl_1_1base_1_1SpaceInformation.html#ac8cadda9547f74d4193c3168a3b2d34f" title="Compute the distance between two states. ">ompl::base::SpaceInformation::distance</a></code> is an admissible heuristic! In fact, this is precisely how we implemented <code><a class="el" href="classompl_1_1base_1_1PathLengthOptimizationObjective.html#a7524f0a3ceb26c0f9819e6e9b6a5f065" title="the motion cost heuristic for this objective is simply the configuration space distance between s1 an...">ompl::base::PathLengthOptimizationObjective::motionCostHeuristic</a></code>:</p>
<div class="fragment"><div class="line"><a class="code" href="structompl_1_1base_1_1Cost.html">ompl::base::Cost</a></div>
<div class="line"><a class="code" href="classompl_1_1base_1_1PathLengthOptimizationObjective.html#a7524f0a3ceb26c0f9819e6e9b6a5f065">ompl::base::PathLengthOptimizationObjective::motionCostHeuristic</a>(<span class="keyword">const</span> State *s1,</div>
<div class="line">                                                                 <span class="keyword">const</span> State *s2)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="keywordflow">return</span> Cost(<a class="code" href="classompl_1_1base_1_1OptimizationObjective.html#aed9801e7e2142d7c61aa586bcacea6c4">si_</a>-&gt;distance(s1, s2));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the default implementation of <code><a class="el" href="classompl_1_1base_1_1OptimizationObjective.html#afd577784b9dedb7bbd5fad9eac23f773" title="Defines an admissible estimate on the optimal cost on the motion between states s1 and s2...">ompl::base::OptimizationObjective::motionCostHeuristic</a></code> simply returns the objective's identity cost, which is guaranteed to be an admissible heuristic for most objectives. However, this isn't a very accurate approximation of motion cost, and motion planners typically experience greater speedups when heuristics more accurately approximate motion cost. Therefore, if your optimal planning problem allows for a more accurate and quick-to-compute admissible heuristic, we recommend you provide one by implementing <code><a class="el" href="classompl_1_1base_1_1OptimizationObjective.html#afd577784b9dedb7bbd5fad9eac23f773" title="Defines an admissible estimate on the optimal cost on the motion between states s1 and s2...">ompl::base::OptimizationObjective::motionCostHeuristic</a></code>.</p>
<h3>Cost-to-go heuristics</h3>
<p>Cost-to-go heuristics can provide even more information to a planner by quickly approximating the optimal path cost between a given state and the goal. However, cost-to-go heuristics must be specified differently from motion cost heuristics: instead of overriding a method as with motion cost heuristics, we need to supply a function pointer to the objective using <code><a class="el" href="classompl_1_1base_1_1OptimizationObjective.html#a3964de818108dd28284e49704f067b9c" title="Set the cost-to-go heuristic function for this objective. The cost-to-go heuristic is a function whic...">ompl::base::OptimizationObjective::setCostToGoHeuristic</a></code>. This is necessary because one optimization objective might be used with many different types of goals, and heuristic calculations can differ depending on the goal type. As with motion cost heuristics, an optimizing planner is most effective when the provided cost-to-go heuristic is admissible and is an adequate approximation of the true optimal path cost between a given state and the goal.</p>
<p>Let's look at how we can use a cost-to-go heuristic in our 2D point robot problem. Assume we're interested in minimizing path length. In this example, the goal is defined as all states within a given tolerance distance of a specified goal state. Therefore, the shortest possible path between a given state and the goal is equal to the straight-line distance between the state and the goal state minus the goal tolerance. This is an admissible heuristic on the cost-to-go distance, and is already defined for you as <code><a class="el" href="namespaceompl_1_1base.html#a009050ed9b663bc4d6d4dbbee94c40b8" title="For use when goal region&#39;s distanceGoal() is equivalent to the cost-to-go of a state under the optimi...">ompl::base::goalRegionCostToGo</a></code>:</p>
<div class="fragment"><div class="line"><a class="code" href="structompl_1_1base_1_1Cost.html">ompl::base::Cost</a> <a class="code" href="namespaceompl_1_1base.html#a009050ed9b663bc4d6d4dbbee94c40b8">ompl::base::goalRegionCostToGo</a>(<span class="keyword">const</span> State* state, <span class="keyword">const</span> Goal* goal)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> GoalRegion* goalRegion = goal-&gt;as&lt;GoalRegion&gt;();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Ensures that all states within the goal region&#39;s threshold to</span></div>
<div class="line">    <span class="comment">// have a cost-to-go of exactly zero.</span></div>
<div class="line">    <span class="keywordflow">return</span> Cost(std::max(goalRegion-&gt;distanceGoal(state) - goalRegion-&gt;getThreshold(),</div>
<div class="line">                         0.0));</div>
<div class="line">}</div>
</div><!-- fragment --><p>This cost-to-go heuristic function can handle any goal of type <code><a class="el" href="classompl_1_1base_1_1GoalRegion.html" title="Definition of a goal region. ">ompl::base::GoalRegion</a></code>, because these goals define a notion of goal distance in the form of <code><a class="el" href="classompl_1_1base_1_1GoalRegion.html#a4c7a9ab388d762c76711790af0ba53ea" title="Compute the distance to the goal (heuristic). This function is the one used in computing the distance...">ompl::base::GoalRegion::distanceGoal</a></code>. We have to subtract the goal threshold in the cost-to-go calculation because the shortest path to the goal from a given state isn't to the center of the goal region, but to the boundary. Lastly, we use <code>std::max</code> to ensure we don't return a negative cost. We can create a path length objective that uses this cost-to-go heuristic with the following function:</p>
<div class="fragment"><div class="line"><a class="code" href="classompl_1_1base_1_1OptimizationObjectivePtr.html">ob::OptimizationObjectivePtr</a> getPathLengthObjWithCostToGo(<span class="keyword">const</span> <a class="code" href="classompl_1_1base_1_1SpaceInformationPtr.html">ob::SpaceInformationPtr</a>&amp; si)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classompl_1_1base_1_1OptimizationObjectivePtr.html">ob::OptimizationObjectivePtr</a> obj(<span class="keyword">new</span> <a class="code" href="classompl_1_1base_1_1PathLengthOptimizationObjective.html">ob::PathLengthOptimizationObjective</a>(si));</div>
<div class="line">    obj-&gt;setCostToGoHeuristic(&amp;ob::goalRegionCostToGo);</div>
<div class="line">    <span class="keywordflow">return</span> obj;</div>
<div class="line">}</div>
</div><!-- fragment --><p>It's extremely important to note that the <code><a class="el" href="namespaceompl_1_1base.html#a009050ed9b663bc4d6d4dbbee94c40b8" title="For use when goal region&#39;s distanceGoal() is equivalent to the cost-to-go of a state under the optimi...">ompl::base::goalRegionCostToGo</a></code> heuristic is only valid for your planning problem if <code><a class="el" href="classompl_1_1base_1_1GoalRegion.html#a4c7a9ab388d762c76711790af0ba53ea" title="Compute the distance to the goal (heuristic). This function is the one used in computing the distance...">ompl::base::GoalRegion::distanceGoal</a></code> is an admissible heuristic on the optimal path cost from a state to your goal region. For instance, if you're planning with <code><a class="el" href="classompl_1_1base_1_1MaximizeMinClearanceObjective.html" title="Objective for attempting to maximize the minimum clearance along a path. ">ompl::base::MaximizeMinClearanceObjective</a></code> to maximize minimum path clearance, the <code><a class="el" href="namespaceompl_1_1base.html#a009050ed9b663bc4d6d4dbbee94c40b8" title="For use when goal region&#39;s distanceGoal() is equivalent to the cost-to-go of a state under the optimi...">ompl::base::goalRegionCostToGo</a></code> function would not be a suitable cost-to-go heuristic because <code><a class="el" href="classompl_1_1base_1_1GoalRegion.html#a4c7a9ab388d762c76711790af0ba53ea" title="Compute the distance to the goal (heuristic). This function is the one used in computing the distance...">ompl::base::GoalRegion::distanceGoal</a></code> has no correlation with path clearance. </p>
</div></div><!-- contents -->
</div>
<footer class="footer">
  <div class="container"><p>
    <a href="http://www.kavrakilab.org">Physical and Biological Computing Group</a> &bull;
    <a href="http://www.cs.rice.edu">Department of Computer Science</a> &bull;
    <a href="http://www.rice.edu">Rice University</a><br>
    <span class="gray">Generated on Tue Sep 2 2014 14:32:26 by&#160;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.6</span>
  </p></div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-9156598-2', 'auto');
  ga('send', 'pageview');
</script>
<script src="../js/jquery.js"></script>
<script src="../js/jquery.powertip.min.js"></script>
<script src="../js/bootstrap.min.js"></script>
<script src="../js/dynsections.js"></script>
<script src="../js/ompl.js"></script>
</body>
</html>
