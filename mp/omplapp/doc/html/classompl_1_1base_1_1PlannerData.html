<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ompl::base::PlannerData Class Reference</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Ioan A. È˜ucan, Mark Moll, Lydia E. Kavraki">
  <link href="../css/tabs.css" rel="stylesheet">
  <link href="../css/doxygen.css" rel="stylesheet">
  <link href="../css/search.css" rel="stylesheet">
  <link href="../css/bootstrap.min.css" rel="stylesheet">
  <link href="../css/bootstrap-theme.min.css" rel="stylesheet">
  <link href="../css/ompl.css" rel="stylesheet">
  <!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
  <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->
  <script src="search/search.js"></script>
</head>
<body>
  <nav class="navbar navbar-inverse navbar-fixed-top" id="top" role="navigation">
    <div class="container">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="./index.html">OMPL</a>
      </div>
      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse navbar-collapse" id="navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="download.html">Download</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="http://ompl.kavrakilab.org/OMPL_Primer.pdf">Primer</a></li>
              <li><a href="installation.html">Installation</a></li>
              <li><a href="tutorials.html">Tutorials</a></li>
              <li><a href="group__demos.html">Demos</a></li>
              <li><a href="gui.html">OMPL.app GUI</a></li>
              <li><a href="python.html">Python Bindings</a></li>
              <li><a href="planners.html">Available Planners</a></li>
              <li><a href="spaces.html">Available State Spaces</a></li>
              <li><a href="optimalPlanning.html">Optimal Planning</a></li>
              <li><a href="FAQ.html">FAQ</a></li>
              <li class="divider"></li>
              <li>&nbsp;<em>External links:</em></li>
              <li><a href="http://moveit.ros.org">MoveIt!</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FOMPL">Japanese Introduction to OMPL</a></li>
              <li><a href="http://robotics.naist.jp/edu/text/?Robotics%2FExercise%2FOMPLProgramming">Japanese OMPL Tutorial</a></li>
              <li><a href="http://moveit.ros.org/wiki/Tutorials/ICRA2013">ICRA 2013 Tutorial</a></li>
              <li><a href="http://kavrakilab.org/OMPLtutorial">IROS 2011 Tutorial</a></li>
            </ul>
          </li>
          <li><a href="gallery.html">Gallery</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Code <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="api_overview.html">API Overview</a></li>
              <li><a href="annotated.html">Classes</a></li>
              <li><a href="files.html">Files</a></li>
              <li><a href="styleGuide.html">Style Guide</a></li>
              <li><a href="https://bitbucket.org/ompl/ompl/src">Browse Repository</a></li>
              <li><a href="teamcity.html">TeamCity Build Server</a></li>
            </ul>
          </li>
          <li><a href="https://bitbucket.org/ompl/ompl/issues?status=new&status=open">Issues</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="mailingLists.html">Mailing Lists</a></li>
              <li><a href="developers.html">Developers</a></li>
              <li><a href="thirdparty.html">Contributions</a></li>
              <li><a href="contrib.html">Submit Contribution</a></li>
              <li><a href="education.html">Education</a></li>
            </ul>
          </li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
              <li><a href="license.html">License</a></li>
              <li><a href="citations.html">Citations</a></li>
              <li><a href="acknowledgements.html">Acknowledgments</a></li>
              <li><a href="contact.html">Contact Us</a></li>
            </ul>
          </li>
          <li><a href="http://ompl.kavrakilab.org/blog/">Blog</a></li>
          <!-- Doxygen API search box -->
          <div id="searchli">
            <div id="MSearchBox" class="MSearchBoxInactive">
              <span class="left">
                <img id="MSearchSelect" src="search/mag_sel.png"
                onmouseover="return searchBox.OnSearchSelectShow()"
                onmouseout="return searchBox.OnSearchSelectHide()"
                alt=""/>
                <input type="text" id="MSearchField" value="Search API" accesskey="S"
                onfocus="searchBox.OnSearchFieldFocus(true)"
                onblur="searchBox.OnSearchFieldFocus(false)"
                onkeyup="searchBox.OnSearchFieldChange(event)"/>
              </span><span class="right">
                <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
              </span>
            </div>
          </div>
        </ul>
      </div>
    </div>
  </nav>
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"
  onmouseover="return searchBox.OnSearchSelectShow()"
  onmouseout="return searchBox.OnSearchSelectHide()"
  onkeydown="return searchBox.OnSearchSelectKey(event)">
  <a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow">
    <iframe src="" frameborder="0"name="MSearchResults" id="MSearchResults"></iframe>
  </div>
  <div class="container" role="main">
    <div>
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceompl.html">ompl</a></li><li class="navelem"><a class="el" href="namespaceompl_1_1base.html">base</a></li><li class="navelem"><a class="el" href="classompl_1_1base_1_1PlannerData.html">PlannerData</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classompl_1_1base_1_1PlannerData-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ompl::base::PlannerData Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Object containing planner generated vertex and edge data. It is assumed that all vertices are unique, and only a single directed edge connects two vertices.  
 <a href="classompl_1_1base_1_1PlannerData.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="base_2PlannerData_8h_source.html">PlannerData.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ompl::base::PlannerData:</div>
<div class="dyncontent">
<div class="center"><img src="classompl_1_1base_1_1PlannerData__inherit__graph.png" border="0" usemap="#ompl_1_1base_1_1PlannerData_inherit__map" alt="Inheritance graph"/></div>
<map name="ompl_1_1base_1_1PlannerData_inherit__map" id="ompl_1_1base_1_1PlannerData_inherit__map">
<area shape="rect" id="node3" href="classompl_1_1control_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique..." alt="" coords="5,155,181,181"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData_1_1Graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for the Boost.Graph representation of the <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...">PlannerData</a>. This class inherits from a boost::adjacency_list <a class="el" href="classompl_1_1base_1_1PlannerData_1_1Graph.html" title="Wrapper class for the Boost.Graph representation of the PlannerData. This class inherits from a boost...">Graph</a> structure.  <a href="classompl_1_1base_1_1PlannerData_1_1Graph.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a18b0a1ffcb25445a7a3c3a132275554e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18b0a1ffcb25445a7a3c3a132275554e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a18b0a1ffcb25445a7a3c3a132275554e">PlannerData</a> (const <a class="el" href="classompl_1_1base_1_1SpaceInformationPtr.html">SpaceInformationPtr</a> &amp;si)</td></tr>
<tr class="memdesc:a18b0a1ffcb25445a7a3c3a132275554e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. Accepts a <a class="el" href="classompl_1_1base_1_1SpaceInformationPtr.html" title="A boost shared pointer wrapper for ompl::base::SpaceInformation. ">SpaceInformationPtr</a> for the space planned in. <br/></td></tr>
<tr class="separator:a18b0a1ffcb25445a7a3c3a132275554e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaae435c61fbc1f4c894da0140830e68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaae435c61fbc1f4c894da0140830e68"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#aeaae435c61fbc1f4c894da0140830e68">~PlannerData</a> ()</td></tr>
<tr class="memdesc:aeaae435c61fbc1f4c894da0140830e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:aeaae435c61fbc1f4c894da0140830e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037587d9bdfccb631ff9b494c1b6af92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a037587d9bdfccb631ff9b494c1b6af92"></a>
const <a class="el" href="classompl_1_1base_1_1SpaceInformationPtr.html">SpaceInformationPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a037587d9bdfccb631ff9b494c1b6af92">getSpaceInformation</a> () const </td></tr>
<tr class="memdesc:a037587d9bdfccb631ff9b494c1b6af92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the instance of <a class="el" href="classompl_1_1base_1_1SpaceInformation.html" title="The base class for space information. This contains all the information about the space planning is d...">SpaceInformation</a> used in this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...">PlannerData</a>. <br/></td></tr>
<tr class="separator:a037587d9bdfccb631ff9b494c1b6af92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee1c1a4c085d16b2aedc573e1d6a956"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ee1c1a4c085d16b2aedc573e1d6a956"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a7ee1c1a4c085d16b2aedc573e1d6a956">hasControls</a> () const </td></tr>
<tr class="memdesc:a7ee1c1a4c085d16b2aedc573e1d6a956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether any information about controls (<a class="el" href="classompl_1_1control_1_1Control.html" title="Definition of an abstract control. ">ompl::control::Control</a>) is stored in this instance. <br/></td></tr>
<tr class="separator:a7ee1c1a4c085d16b2aedc573e1d6a956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PlannerData construction</div></td></tr>
<tr class="memitem:ac61c5ab5cfd6a66a58e03b1731c1e454"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac61c5ab5cfd6a66a58e03b1731c1e454"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ac61c5ab5cfd6a66a58e03b1731c1e454">addVertex</a> (const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;st)</td></tr>
<tr class="memdesc:ac61c5ab5cfd6a66a58e03b1731c1e454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given vertex to the graph data. The vertex index is returned. Duplicates are not added. If a vertex is duplicated, the index of the existing vertex is returned instead. Indexes are volatile and may change after adding/removing a subsequent vertex. <br/></td></tr>
<tr class="separator:ac61c5ab5cfd6a66a58e03b1731c1e454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eea84456784452486aa0065af391f47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2eea84456784452486aa0065af391f47"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a2eea84456784452486aa0065af391f47">addStartVertex</a> (const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;v)</td></tr>
<tr class="memdesc:a2eea84456784452486aa0065af391f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given vertex to the graph data, and marks it as a start vertex. The vertex index is returned. Duplicates are not added. If a vertex is duplicated, the index of the existing vertex is returned instead. Indexes are volatile and may change after adding/removing a subsequent vertex. <br/></td></tr>
<tr class="separator:a2eea84456784452486aa0065af391f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3604cb85b0402b09b319c5f1df02b12e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3604cb85b0402b09b319c5f1df02b12e"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a3604cb85b0402b09b319c5f1df02b12e">addGoalVertex</a> (const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;v)</td></tr>
<tr class="memdesc:a3604cb85b0402b09b319c5f1df02b12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given vertex to the graph data, and marks it as a start vertex. The vertex index is returned. Duplicates are not added. If a vertex is duplicated, the index of the existing vertex is returned instead. Indexes are volatile and may change after adding/removing a subsequent vertex. <br/></td></tr>
<tr class="separator:a3604cb85b0402b09b319c5f1df02b12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ebd34b6da9efd9ec7647155f9173c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48ebd34b6da9efd9ec7647155f9173c9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a48ebd34b6da9efd9ec7647155f9173c9">markStartState</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *st)</td></tr>
<tr class="memdesc:a48ebd34b6da9efd9ec7647155f9173c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the given state as a start vertex. If the given state does not exist in a vertex, false is returned. <br/></td></tr>
<tr class="separator:a48ebd34b6da9efd9ec7647155f9173c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7772ac307d153831c0e7ecfc4fb1c18b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7772ac307d153831c0e7ecfc4fb1c18b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a7772ac307d153831c0e7ecfc4fb1c18b">markGoalState</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *st)</td></tr>
<tr class="memdesc:a7772ac307d153831c0e7ecfc4fb1c18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the given state as a goal vertex. If the given state does not exist in a vertex, false is returned. <br/></td></tr>
<tr class="separator:a7772ac307d153831c0e7ecfc4fb1c18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0b7c124dcac4f07c5f6d0ab51386a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b0b7c124dcac4f07c5f6d0ab51386a6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a2b0b7c124dcac4f07c5f6d0ab51386a6">tagState</a> (const <a class="el" href="classompl_1_1base_1_1State.html">State</a> *st, int tag)</td></tr>
<tr class="memdesc:a2b0b7c124dcac4f07c5f6d0ab51386a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the integer tag associated with the given state. If the given state does not exist in a vertex, false is returned. <br/></td></tr>
<tr class="separator:a2b0b7c124dcac4f07c5f6d0ab51386a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a2c3ad28a32136c74ad9f841727f01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75a2c3ad28a32136c74ad9f841727f01"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a75a2c3ad28a32136c74ad9f841727f01">removeVertex</a> (const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;st)</td></tr>
<tr class="memdesc:a75a2c3ad28a32136c74ad9f841727f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the vertex associated with the given data. If the vertex does not exist, false is returned. This method has O(n) complexity in the number of vertices. <br/></td></tr>
<tr class="separator:a75a2c3ad28a32136c74ad9f841727f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7313c0b88697387feebff969c307193c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7313c0b88697387feebff969c307193c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a7313c0b88697387feebff969c307193c">removeVertex</a> (unsigned int vIndex)</td></tr>
<tr class="memdesc:a7313c0b88697387feebff969c307193c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the vertex with the given index. If the index is out of range, false is returned. This method has O(n) complexity in the number of vertices. <br/></td></tr>
<tr class="separator:a7313c0b88697387feebff969c307193c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09c21494a8c7db500ef1a66bbbb1aa7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac09c21494a8c7db500ef1a66bbbb1aa7"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ac09c21494a8c7db500ef1a66bbbb1aa7">addEdge</a> (unsigned int v1, unsigned int v2, const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a> &amp;edge=<a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a>(), <a class="el" href="structompl_1_1base_1_1Cost.html">Cost</a> weight=<a class="el" href="structompl_1_1base_1_1Cost.html">Cost</a>(1.0))</td></tr>
<tr class="memdesc:ac09c21494a8c7db500ef1a66bbbb1aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a directed edge between the given vertex indexes. An optional edge structure and weight can be supplied. Success is returned. <br/></td></tr>
<tr class="separator:ac09c21494a8c7db500ef1a66bbbb1aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2685cb2025517bdc0ee1ba94b9aff49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2685cb2025517bdc0ee1ba94b9aff49"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ad2685cb2025517bdc0ee1ba94b9aff49">addEdge</a> (const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;v1, const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;v2, const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a> &amp;edge=<a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a>(), <a class="el" href="structompl_1_1base_1_1Cost.html">Cost</a> weight=<a class="el" href="structompl_1_1base_1_1Cost.html">Cost</a>(1.0))</td></tr>
<tr class="memdesc:ad2685cb2025517bdc0ee1ba94b9aff49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a directed edge between the given vertex indexes. The vertices are added to the data if they are not already in the structure. An optional edge structure and weight can also be supplied. Success is returned. <br/></td></tr>
<tr class="separator:ad2685cb2025517bdc0ee1ba94b9aff49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991ab62a502c3f80ae2663150e79bcea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a991ab62a502c3f80ae2663150e79bcea"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a991ab62a502c3f80ae2663150e79bcea">removeEdge</a> (unsigned int v1, unsigned int v2)</td></tr>
<tr class="memdesc:a991ab62a502c3f80ae2663150e79bcea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the edge between vertex indexes <em>v1</em> and <em>v2</em>. Success is returned. <br/></td></tr>
<tr class="separator:a991ab62a502c3f80ae2663150e79bcea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda397cf585cc647d1e9b212b6092b0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afda397cf585cc647d1e9b212b6092b0e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#afda397cf585cc647d1e9b212b6092b0e">removeEdge</a> (const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;v1, const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;v2)</td></tr>
<tr class="memdesc:afda397cf585cc647d1e9b212b6092b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the edge between the vertices associated with the given vertex data. Success is returned. <br/></td></tr>
<tr class="separator:afda397cf585cc647d1e9b212b6092b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7378bbca3f1006b70976292266277eb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7378bbca3f1006b70976292266277eb9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a7378bbca3f1006b70976292266277eb9">clear</a> ()</td></tr>
<tr class="memdesc:a7378bbca3f1006b70976292266277eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the entire data structure. <br/></td></tr>
<tr class="separator:a7378bbca3f1006b70976292266277eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01506ec2ff32596dcb1bd9dfa2f8e1d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#af01506ec2ff32596dcb1bd9dfa2f8e1d">decoupleFromPlanner</a> ()</td></tr>
<tr class="memdesc:af01506ec2ff32596dcb1bd9dfa2f8e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of the states contained in the vertices of this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...">PlannerData</a> structure so that when the planner that created this instance goes out of scope, all data remains intact.  <a href="#af01506ec2ff32596dcb1bd9dfa2f8e1d">More...</a><br/></td></tr>
<tr class="separator:af01506ec2ff32596dcb1bd9dfa2f8e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PlannerData Properties</div></td></tr>
<tr class="memitem:aed73a24b4db83fb523fc6e634e2aa335"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed73a24b4db83fb523fc6e634e2aa335"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#aed73a24b4db83fb523fc6e634e2aa335">numEdges</a> () const </td></tr>
<tr class="memdesc:aed73a24b4db83fb523fc6e634e2aa335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of edges in this structure. <br/></td></tr>
<tr class="separator:aed73a24b4db83fb523fc6e634e2aa335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec510507fa061ff368eb3c1826f0009"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ec510507fa061ff368eb3c1826f0009"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a4ec510507fa061ff368eb3c1826f0009">numVertices</a> () const </td></tr>
<tr class="memdesc:a4ec510507fa061ff368eb3c1826f0009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of vertices in this structure. <br/></td></tr>
<tr class="separator:a4ec510507fa061ff368eb3c1826f0009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4ba509f9588515ea527bbbb6f7576c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf4ba509f9588515ea527bbbb6f7576c"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#adf4ba509f9588515ea527bbbb6f7576c">numStartVertices</a> () const </td></tr>
<tr class="memdesc:adf4ba509f9588515ea527bbbb6f7576c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of start vertices. <br/></td></tr>
<tr class="separator:adf4ba509f9588515ea527bbbb6f7576c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e79ddde25349a0fccba68731a3fd5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0e79ddde25349a0fccba68731a3fd5b"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#aa0e79ddde25349a0fccba68731a3fd5b">numGoalVertices</a> () const </td></tr>
<tr class="memdesc:aa0e79ddde25349a0fccba68731a3fd5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of goal vertices. <br/></td></tr>
<tr class="separator:aa0e79ddde25349a0fccba68731a3fd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PlannerData vertex lookup</div></td></tr>
<tr class="memitem:a97659c4427fb4d02204e86b9ad4d0d85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97659c4427fb4d02204e86b9ad4d0d85"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a97659c4427fb4d02204e86b9ad4d0d85">vertexExists</a> (const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;v) const </td></tr>
<tr class="memdesc:a97659c4427fb4d02204e86b9ad4d0d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a vertex exists with the given vertex data. <br/></td></tr>
<tr class="separator:a97659c4427fb4d02204e86b9ad4d0d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5228dd82b9c8b62b9e68546f1dc4da91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5228dd82b9c8b62b9e68546f1dc4da91"></a>
const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a5228dd82b9c8b62b9e68546f1dc4da91">getVertex</a> (unsigned int index) const </td></tr>
<tr class="memdesc:a5228dd82b9c8b62b9e68546f1dc4da91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the vertex object with the given index. If this vertex does not exist, NO_VERTEX is returned. <br/></td></tr>
<tr class="separator:a5228dd82b9c8b62b9e68546f1dc4da91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1f2a259a8861ee5a88e51cc52f69e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e1f2a259a8861ee5a88e51cc52f69e5"></a>
<a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a7e1f2a259a8861ee5a88e51cc52f69e5">getVertex</a> (unsigned int index)</td></tr>
<tr class="memdesc:a7e1f2a259a8861ee5a88e51cc52f69e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the vertex object with the given index. If this vertex does not exist, NO_VERTEX is returned. <br/></td></tr>
<tr class="separator:a7e1f2a259a8861ee5a88e51cc52f69e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affaca04be4ca2658cb0d5e6cd9fbed80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affaca04be4ca2658cb0d5e6cd9fbed80"></a>
const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#affaca04be4ca2658cb0d5e6cd9fbed80">getStartVertex</a> (unsigned int i) const </td></tr>
<tr class="memdesc:affaca04be4ca2658cb0d5e6cd9fbed80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the ith start vertex object. If <em>i</em> is greater than the number of start vertices, NO_VERTEX is returned. <br/></td></tr>
<tr class="separator:affaca04be4ca2658cb0d5e6cd9fbed80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01edd29349d34cd7ca62384cecf7e7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae01edd29349d34cd7ca62384cecf7e7d"></a>
<a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ae01edd29349d34cd7ca62384cecf7e7d">getStartVertex</a> (unsigned int i)</td></tr>
<tr class="memdesc:ae01edd29349d34cd7ca62384cecf7e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the ith start vertex object. If <em>i</em> is greater than the number of start vertices, NO_VERTEX is returned. <br/></td></tr>
<tr class="separator:ae01edd29349d34cd7ca62384cecf7e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af599f3b6eaf5789223facd978d1897b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af599f3b6eaf5789223facd978d1897b9"></a>
const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#af599f3b6eaf5789223facd978d1897b9">getGoalVertex</a> (unsigned int i) const </td></tr>
<tr class="memdesc:af599f3b6eaf5789223facd978d1897b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the ith goal vertex object. If <em>i</em> is greater than the number of goal vertices, NO_VERTEX is returned. <br/></td></tr>
<tr class="separator:af599f3b6eaf5789223facd978d1897b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0740003f5170235f3133162db36f1f23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0740003f5170235f3133162db36f1f23"></a>
<a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a0740003f5170235f3133162db36f1f23">getGoalVertex</a> (unsigned int i)</td></tr>
<tr class="memdesc:a0740003f5170235f3133162db36f1f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the ith goal vertex object. If <em>i</em> is greater than the number of goal vertices, NO_VERTEX is returned. <br/></td></tr>
<tr class="separator:a0740003f5170235f3133162db36f1f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae327af789b89202dc7c68988d0d23175"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae327af789b89202dc7c68988d0d23175"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ae327af789b89202dc7c68988d0d23175">getStartIndex</a> (unsigned int i) const </td></tr>
<tr class="memdesc:ae327af789b89202dc7c68988d0d23175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the ith start state. INVALID_INDEX is returned if <em>i</em> is out of range. Indexes are volatile and may change after adding/removing a vertex. <br/></td></tr>
<tr class="separator:ae327af789b89202dc7c68988d0d23175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86774f579c347fc2ae46d1d501eaec4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86774f579c347fc2ae46d1d501eaec4f"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a86774f579c347fc2ae46d1d501eaec4f">getGoalIndex</a> (unsigned int i) const </td></tr>
<tr class="memdesc:a86774f579c347fc2ae46d1d501eaec4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the ith goal state. INVALID_INDEX is returned if <em>i</em> is out of range Indexes are volatile and may change after adding/removing a vertex. <br/></td></tr>
<tr class="separator:a86774f579c347fc2ae46d1d501eaec4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5da9f36f20bfc503c95cb7c84e8ba37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5da9f36f20bfc503c95cb7c84e8ba37"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ac5da9f36f20bfc503c95cb7c84e8ba37">isStartVertex</a> (unsigned int index) const </td></tr>
<tr class="memdesc:ac5da9f36f20bfc503c95cb7c84e8ba37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given vertex index is marked as a start vertex. <br/></td></tr>
<tr class="separator:ac5da9f36f20bfc503c95cb7c84e8ba37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07adc96f0cfcfc9e418e66b4e0078ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab07adc96f0cfcfc9e418e66b4e0078ad"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ab07adc96f0cfcfc9e418e66b4e0078ad">isGoalVertex</a> (unsigned int index) const </td></tr>
<tr class="memdesc:ab07adc96f0cfcfc9e418e66b4e0078ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given vertex index is marked as a goal vertex. <br/></td></tr>
<tr class="separator:ab07adc96f0cfcfc9e418e66b4e0078ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd081adb8e8a728eab89d57514724f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fd081adb8e8a728eab89d57514724f0"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a8fd081adb8e8a728eab89d57514724f0">vertexIndex</a> (const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a> &amp;v) const </td></tr>
<tr class="memdesc:a8fd081adb8e8a728eab89d57514724f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index for the vertex associated with the given data. INVALID_INDEX is returned if this vertex does not exist. Indexes are volatile and may change after adding/removing a vertex. <br/></td></tr>
<tr class="separator:a8fd081adb8e8a728eab89d57514724f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PlannerData edge lookup</div></td></tr>
<tr class="memitem:a90da79739a42f9b86fa18d8f3af21c8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90da79739a42f9b86fa18d8f3af21c8a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a90da79739a42f9b86fa18d8f3af21c8a">edgeExists</a> (unsigned int v1, unsigned int v2) const </td></tr>
<tr class="memdesc:a90da79739a42f9b86fa18d8f3af21c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an edge between vertex index <em>v1</em> and index <em>v2</em> exists. <br/></td></tr>
<tr class="separator:a90da79739a42f9b86fa18d8f3af21c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635568961308b738919748b839c8f4fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a635568961308b738919748b839c8f4fa"></a>
const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a635568961308b738919748b839c8f4fa">getEdge</a> (unsigned int v1, unsigned int v2) const </td></tr>
<tr class="memdesc:a635568961308b738919748b839c8f4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the edge object connecting vertices with indexes <em>v1</em> and <em>v2</em>. If this edge does not exist, NO_EDGE is returned. <br/></td></tr>
<tr class="separator:a635568961308b738919748b839c8f4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42dd016470505a10e245a570e1979de3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42dd016470505a10e245a570e1979de3"></a>
<a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a42dd016470505a10e245a570e1979de3">getEdge</a> (unsigned int v1, unsigned int v2)</td></tr>
<tr class="memdesc:a42dd016470505a10e245a570e1979de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the edge object connecting vertices with indexes <em>v1</em> and <em>v2</em>. If this edge does not exist, NO_EDGE is returned. <br/></td></tr>
<tr class="separator:a42dd016470505a10e245a570e1979de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0732c2d6732e9da62a98adbe4c82d763"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0732c2d6732e9da62a98adbe4c82d763"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a0732c2d6732e9da62a98adbe4c82d763">getEdges</a> (unsigned int v, std::vector&lt; unsigned int &gt; &amp;edgeList) const </td></tr>
<tr class="memdesc:a0732c2d6732e9da62a98adbe4c82d763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the vertex indexes directly connected to vertex with index <em>v</em> (outgoing edges). The number of outgoing edges from <em>v</em> is returned. <br/></td></tr>
<tr class="separator:a0732c2d6732e9da62a98adbe4c82d763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb08d67d9ace07380a8d72c014a97af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfb08d67d9ace07380a8d72c014a97af"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#acfb08d67d9ace07380a8d72c014a97af">getEdges</a> (unsigned int v, std::map&lt; unsigned int, const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a> * &gt; &amp;edgeMap) const </td></tr>
<tr class="memdesc:acfb08d67d9ace07380a8d72c014a97af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map of outgoing edges from vertex with index <em>v</em>. Key = vertex index, value = edge structure. The number of outgoing edges from <em>v</em> is returned. <br/></td></tr>
<tr class="separator:acfb08d67d9ace07380a8d72c014a97af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a484d02c69f7057e73ee1af1be6f05b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a484d02c69f7057e73ee1af1be6f05b"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a9a484d02c69f7057e73ee1af1be6f05b">getIncomingEdges</a> (unsigned int v, std::vector&lt; unsigned int &gt; &amp;edgeList) const </td></tr>
<tr class="memdesc:a9a484d02c69f7057e73ee1af1be6f05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of vertices with outgoing edges to the vertex with index <em>v</em>. The number of edges connecting to <em>v</em> is returned. <br/></td></tr>
<tr class="separator:a9a484d02c69f7057e73ee1af1be6f05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612b839eacd191500df798ae9587ef8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a612b839eacd191500df798ae9587ef8a"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a612b839eacd191500df798ae9587ef8a">getIncomingEdges</a> (unsigned int v, std::map&lt; unsigned int, const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a> * &gt; &amp;edgeMap) const </td></tr>
<tr class="memdesc:a612b839eacd191500df798ae9587ef8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map of incoming edges to the vertex with index <em>v</em> (i.e. if there is an edge from w to v, w and the edge structure will be in the map.) Key = vertex index, value = edge structure. The number of incoming edges to <em>v</em> is returned. <br/></td></tr>
<tr class="separator:a612b839eacd191500df798ae9587ef8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad7bb69b33a92a1c5e614680bd8f628"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ad7bb69b33a92a1c5e614680bd8f628"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a3ad7bb69b33a92a1c5e614680bd8f628">getEdgeWeight</a> (unsigned int v1, unsigned int v2, <a class="el" href="structompl_1_1base_1_1Cost.html">Cost</a> *weight) const </td></tr>
<tr class="memdesc:a3ad7bb69b33a92a1c5e614680bd8f628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weight of the edge between the given vertex indices. If there exists an edge between <em>v1</em> and , the edge weight is placed in the out-variable <em>weight</em>. Otherwise, this function returns false. <br/></td></tr>
<tr class="separator:a3ad7bb69b33a92a1c5e614680bd8f628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0989a6e1614d76a1f94fb54d67341f5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0989a6e1614d76a1f94fb54d67341f5d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a0989a6e1614d76a1f94fb54d67341f5d">setEdgeWeight</a> (unsigned int v1, unsigned int v2, <a class="el" href="structompl_1_1base_1_1Cost.html">Cost</a> weight)</td></tr>
<tr class="memdesc:a0989a6e1614d76a1f94fb54d67341f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the weight of the edge between the given vertex indices. If an edge between v1 and v2 does not exist, this function returns false. <br/></td></tr>
<tr class="separator:a0989a6e1614d76a1f94fb54d67341f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf46a3a30292549f151136489c0d7041"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf46a3a30292549f151136489c0d7041"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#abf46a3a30292549f151136489c0d7041">computeEdgeWeights</a> (const <a class="el" href="classompl_1_1base_1_1OptimizationObjective.html">OptimizationObjective</a> &amp;opt)</td></tr>
<tr class="memdesc:abf46a3a30292549f151136489c0d7041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the weight for all edges given the <a class="el" href="classompl_1_1base_1_1OptimizationObjective.html" title="Abstract definition of optimization objectives. ">OptimizationObjective</a> <em>opt</em>. <br/></td></tr>
<tr class="separator:abf46a3a30292549f151136489c0d7041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238a60c0e598a6e60c9be24f12e044f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a238a60c0e598a6e60c9be24f12e044f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a238a60c0e598a6e60c9be24f12e044f4">computeEdgeWeights</a> ()</td></tr>
<tr class="memdesc:a238a60c0e598a6e60c9be24f12e044f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all edge weights using state space distance (i.e. <a class="el" href="classompl_1_1base_1_1PlannerData.html#a037587d9bdfccb631ff9b494c1b6af92" title="Return the instance of SpaceInformation used in this PlannerData. ">getSpaceInformation()</a>-&gt;distance()) <br/></td></tr>
<tr class="separator:a238a60c0e598a6e60c9be24f12e044f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Output methods</div></td></tr>
<tr class="memitem:aa637f3586c632363498054311aee61dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa637f3586c632363498054311aee61dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#aa637f3586c632363498054311aee61dd">printGraphviz</a> (std::ostream &amp;out=std::cout) const </td></tr>
<tr class="memdesc:aa637f3586c632363498054311aee61dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a Graphviz dot file of this structure to the given stream. <br/></td></tr>
<tr class="separator:aa637f3586c632363498054311aee61dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaecec6b16a335917a011e5381f42929"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afaecec6b16a335917a011e5381f42929"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#afaecec6b16a335917a011e5381f42929">printGraphML</a> (std::ostream &amp;out=std::cout) const </td></tr>
<tr class="memdesc:afaecec6b16a335917a011e5381f42929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a GraphML file of this structure to the given stream. <br/></td></tr>
<tr class="separator:afaecec6b16a335917a011e5381f42929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Advanced graph extraction</div></td></tr>
<tr class="memitem:ac45aec73f0452702d4c8a69f3fa664bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac45aec73f0452702d4c8a69f3fa664bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ac45aec73f0452702d4c8a69f3fa664bf">extractMinimumSpanningTree</a> (unsigned int v, const <a class="el" href="classompl_1_1base_1_1OptimizationObjective.html">OptimizationObjective</a> &amp;opt, <a class="el" href="classompl_1_1base_1_1PlannerData.html">PlannerData</a> &amp;mst) const </td></tr>
<tr class="memdesc:ac45aec73f0452702d4c8a69f3fa664bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the minimum spanning tree of the data rooted at the vertex with index <em>v</em>. The minimum spanning tree is saved into <em>mst</em>. O(|E| log |V|) complexity. <br/></td></tr>
<tr class="separator:ac45aec73f0452702d4c8a69f3fa664bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69dd695b9fbe2662e2a09bd37c9d96b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab69dd695b9fbe2662e2a09bd37c9d96b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ab69dd695b9fbe2662e2a09bd37c9d96b">extractReachable</a> (unsigned int v, <a class="el" href="classompl_1_1base_1_1PlannerData.html">PlannerData</a> &amp;data) const </td></tr>
<tr class="memdesc:ab69dd695b9fbe2662e2a09bd37c9d96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the subset of <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...">PlannerData</a> reachable from the vertex with index v. For tree structures, this will be the sub-tree rooted at v. The reachable set is saved into <em>data</em>. <br/></td></tr>
<tr class="separator:ab69dd695b9fbe2662e2a09bd37c9d96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6201d765fd53de907946dffb687ffd68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6201d765fd53de907946dffb687ffd68"></a>
StateStoragePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a6201d765fd53de907946dffb687ffd68">extractStateStorage</a> () const </td></tr>
<tr class="memdesc:a6201d765fd53de907946dffb687ffd68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a <a class="el" href="namespaceompl_1_1base.html#a22b265d9afab284f0d4a1ad22d339a9a" title="Storage of states where the metadata is a vector of indices. This is is typically used to store a gra...">ompl::base::GraphStateStorage</a> object from this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...">PlannerData</a>. Memory for states is copied (the resulting <a class="el" href="classompl_1_1base_1_1StateStorage.html" title="Manage loading and storing for a set of states of a specified state space. ">ompl::base::StateStorage</a> is independent from this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...">PlannerData</a>) <br/></td></tr>
<tr class="separator:a6201d765fd53de907946dffb687ffd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919452f1e347b68e9331d726c85b1dad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classompl_1_1base_1_1PlannerData_1_1Graph.html">Graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a919452f1e347b68e9331d726c85b1dad">toBoostGraph</a> ()</td></tr>
<tr class="memdesc:a919452f1e347b68e9331d726c85b1dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a Boost.Graph object from this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...">PlannerData</a>.  <a href="#a919452f1e347b68e9331d726c85b1dad">More...</a><br/></td></tr>
<tr class="separator:a919452f1e347b68e9331d726c85b1dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f158175b4d5fd12e4a660c4be8b02f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classompl_1_1base_1_1PlannerData_1_1Graph.html">Graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a6f158175b4d5fd12e4a660c4be8b02f5">toBoostGraph</a> () const </td></tr>
<tr class="memdesc:a6f158175b4d5fd12e4a660c4be8b02f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a Boost.Graph object from this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...">PlannerData</a>.  <a href="#a6f158175b4d5fd12e4a660c4be8b02f5">More...</a><br/></td></tr>
<tr class="separator:a6f158175b4d5fd12e4a660c4be8b02f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aca9e2da9d9a46e42c516fc8b926ab65c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca9e2da9d9a46e42c516fc8b926ab65c"></a>
std::map&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#aca9e2da9d9a46e42c516fc8b926ab65c">properties</a></td></tr>
<tr class="memdesc:aca9e2da9d9a46e42c516fc8b926ab65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any extra properties (key-value pairs) the planner can set. <br/></td></tr>
<tr class="separator:aca9e2da9d9a46e42c516fc8b926ab65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5e9068cf84bb1c378eb2ec0823e086d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e9068cf84bb1c378eb2ec0823e086d2"></a>
static const <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">PlannerDataEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a5e9068cf84bb1c378eb2ec0823e086d2">NO_EDGE</a> = <a class="el" href="classompl_1_1base_1_1PlannerDataEdge.html">ompl::base::PlannerDataEdge</a>()</td></tr>
<tr class="memdesc:a5e9068cf84bb1c378eb2ec0823e086d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation for a non-existant edge. <br/></td></tr>
<tr class="separator:a5e9068cf84bb1c378eb2ec0823e086d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b2294e37eb1b5468d70c04055f64c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53b2294e37eb1b5468d70c04055f64c8"></a>
static const <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">PlannerDataVertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a53b2294e37eb1b5468d70c04055f64c8">NO_VERTEX</a> = <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html">ompl::base::PlannerDataVertex</a>(0)</td></tr>
<tr class="memdesc:a53b2294e37eb1b5468d70c04055f64c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation for a non-existant vertex. <br/></td></tr>
<tr class="separator:a53b2294e37eb1b5468d70c04055f64c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b09299d9980783a8147e280562d5a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2b09299d9980783a8147e280562d5a7"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#ab2b09299d9980783a8147e280562d5a7">INVALID_INDEX</a> = std::numeric_limits&lt;unsigned int&gt;::max()</td></tr>
<tr class="memdesc:ab2b09299d9980783a8147e280562d5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of an invalid vertex index. <br/></td></tr>
<tr class="separator:ab2b09299d9980783a8147e280562d5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4217eef33f9fc70fb4ee2ffbe34377ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4217eef33f9fc70fb4ee2ffbe34377ac"></a>
std::map&lt; const <a class="el" href="classompl_1_1base_1_1State.html">State</a> <br class="typebreak"/>
*, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a4217eef33f9fc70fb4ee2ffbe34377ac">stateIndexMap_</a></td></tr>
<tr class="memdesc:a4217eef33f9fc70fb4ee2ffbe34377ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mapping of states to vertex indexes. For fast lookup of vertex index. <br/></td></tr>
<tr class="separator:a4217eef33f9fc70fb4ee2ffbe34377ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b96459e98ddbbe4882a4c2ca64738d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b96459e98ddbbe4882a4c2ca64738d8"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a5b96459e98ddbbe4882a4c2ca64738d8">startVertexIndices_</a></td></tr>
<tr class="memdesc:a5b96459e98ddbbe4882a4c2ca64738d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable listing of the vertices marked as start states. Stored in sorted order. <br/></td></tr>
<tr class="separator:a5b96459e98ddbbe4882a4c2ca64738d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1793ebfefa6fbaeaf6dda5431f58be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf1793ebfefa6fbaeaf6dda5431f58be"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#abf1793ebfefa6fbaeaf6dda5431f58be">goalVertexIndices_</a></td></tr>
<tr class="memdesc:abf1793ebfefa6fbaeaf6dda5431f58be"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable listing of the vertices marked as goal states. Stored in sorted order. <br/></td></tr>
<tr class="separator:abf1793ebfefa6fbaeaf6dda5431f58be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b265d3a5780cda11ba7d068953c74af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b265d3a5780cda11ba7d068953c74af"></a>
<a class="el" href="classompl_1_1base_1_1SpaceInformationPtr.html">SpaceInformationPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a9b265d3a5780cda11ba7d068953c74af">si_</a></td></tr>
<tr class="memdesc:a9b265d3a5780cda11ba7d068953c74af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The space information instance for this data. <br/></td></tr>
<tr class="separator:a9b265d3a5780cda11ba7d068953c74af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c58c4c2809cbd8f70d21b452317307"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00c58c4c2809cbd8f70d21b452317307"></a>
std::set&lt; <a class="el" href="classompl_1_1base_1_1State.html">State</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classompl_1_1base_1_1PlannerData.html#a00c58c4c2809cbd8f70d21b452317307">decoupledStates_</a></td></tr>
<tr class="memdesc:a00c58c4c2809cbd8f70d21b452317307"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of states that are allocated during the decoupleFromPlanner method. These states are freed by <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...">PlannerData</a> in the destructor. <br/></td></tr>
<tr class="separator:a00c58c4c2809cbd8f70d21b452317307"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Object containing planner generated vertex and edge data. It is assumed that all vertices are unique, and only a single directed edge connects two vertices. </p>
<dl class="section note"><dt>Note</dt><dd>The storage for states this class maintains belongs to the planner instance that filled the data (by default; see <a class="el" href="classompl_1_1base_1_1PlannerData.html#af01506ec2ff32596dcb1bd9dfa2f8e1d" title="Creates a deep copy of the states contained in the vertices of this PlannerData structure so that whe...">PlannerData::decoupleFromPlanner()</a>) </dd></dl>

<p>Definition at line <a class="el" href="base_2PlannerData_8h_source.html#l00164">164</a> of file <a class="el" href="base_2PlannerData_8h_source.html">PlannerData.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af01506ec2ff32596dcb1bd9dfa2f8e1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ompl::base::PlannerData::decoupleFromPlanner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deep copy of the states contained in the vertices of this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...">PlannerData</a> structure so that when the planner that created this instance goes out of scope, all data remains intact. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Shallow state pointers inside of the <a class="el" href="classompl_1_1base_1_1PlannerDataVertex.html" title="Base class for a vertex in the PlannerData structure. All derived classes must implement the clone an...">PlannerDataVertex</a> objects already in this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...">PlannerData</a> will be replaced with clones which are scoped to this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...">PlannerData</a> object. A subsequent call to this method is necessary after any other vertices are added to ensure that this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...">PlannerData</a> instance is fully decoupled. </dd></dl>

<p>Reimplemented in <a class="el" href="classompl_1_1control_1_1PlannerData.html#a5b2979d822c9fa21ed3d294cadfde2a7">ompl::control::PlannerData</a>.</p>

<p>Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00084">84</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a919452f1e347b68e9331d726c85b1dad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classompl_1_1base_1_1PlannerData_1_1Graph.html">ompl::base::PlannerData::Graph</a> &amp; ompl::base::PlannerData::toBoostGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a Boost.Graph object from this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...">PlannerData</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Use of this method requires inclusion of <a class="el" href="PlannerDataGraph_8h_source.html">PlannerDataGraph.h</a> The object returned can be used safely for all read-only purposes in Boost. Adding or removing vertices and edges should be performed by using the respective method in <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...">PlannerData</a> to ensure proper memory management. Manipulating the graph directly will result in undefined behavior with this class. </dd></dl>

<p>Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00761">761</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f158175b4d5fd12e4a660c4be8b02f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classompl_1_1base_1_1PlannerData_1_1Graph.html">ompl::base::PlannerData::Graph</a> &amp; ompl::base::PlannerData::toBoostGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a Boost.Graph object from this <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...">PlannerData</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Use of this method requires inclusion of <a class="el" href="PlannerDataGraph_8h_source.html">PlannerDataGraph.h</a> The object returned can be used safely for all read-only purposes in Boost. Adding or removing vertices and edges should be performed by using the respective method in <a class="el" href="classompl_1_1base_1_1PlannerData.html" title="Object containing planner generated vertex and edge data. It is assumed that all vertices are unique...">PlannerData</a> to ensure proper memory management. Manipulating the graph directly will result in undefined behavior with this class. </dd></dl>

<p>Definition at line <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html#l00767">767</a> of file <a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ompl/src/ompl/base/<a class="el" href="base_2PlannerData_8h_source.html">PlannerData.h</a></li>
<li>ompl/src/ompl/base/src/<a class="el" href="src_2ompl_2base_2src_2PlannerData_8cpp_source.html">PlannerData.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
<footer class="footer">
  <div class="container"><p>
    <a href="http://www.kavrakilab.org">Physical and Biological Computing Group</a> &bull;
    <a href="http://www.cs.rice.edu">Department of Computer Science</a> &bull;
    <a href="http://www.rice.edu">Rice University</a><br>
    <span class="gray">Generated on Tue Sep 2 2014 14:32:27 by&#160;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.6</span>
  </p></div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-9156598-2', 'auto');
  ga('send', 'pageview');
</script>
<script src="../js/jquery.js"></script>
<script src="../js/jquery.powertip.min.js"></script>
<script src="../js/bootstrap.min.js"></script>
<script src="../js/dynsections.js"></script>
<script src="../js/ompl.js"></script>
</body>
</html>
